#+STARTUP: showeverything
#+OPTIONS: toc:4 h:4
#+TITLE: Adam Taylor's  Emacs Initialization
* Overview
  This is my literate and *portable* Emacs initialization "system."
** Quick start
   Just git clone this repository into ~~/.emacs.d~: ~git clone https://github.com/Atman50/emacs-config.git ~/.emacs.d~

   Now just fire up Emacs and all the packages/configuration loads. It takes a bit the first time as it has to download and install the various packages, however it is much quicker on subsequent runs. This makes this configuration *highly portable*. Perhaps the only changes to make for different systems is in the ~custom.el~ file that references Windows or Linux/Unix style file/directory names. I have not found a good solution for this other than creating a handy git stash for keeping system changes that can be applied after updating (fetching and merging) from the remote git repository.

   A minor warning is that Emacs load times can be somewhat slow (10 or so seconds). Startup continues to degrade as the size of the desktop file increases (the more files that need to be opened at the start of Emacs).

** ~init.el~ explained
   To get the literate configuration, some amount of system setup is necessary and is entirely contained in my simple ~init.el~ file. Here are the pieces explained.

   Note that these pieces of ~init.el~ are *not* tangled (extraced) by ~org-babel-load-file~ (":tangle no" on the elisp code blocks here).

*** First, load customizations
    I split my customizations out into their own file ~custom.el~ and try as best as I can to keep all my customizations there. The reason is that they work well with the Emacs customization system so that when you look at ~M-x describe-variable~ the documentation says it was customized and not "changed outside of customization".

    So, *first things first*, load up the customizations:
    #+begin_src emacs-lisp :tangle no
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (load custom-file t)
    #+end_src

*** Initialize package system
    Make sure the package system is up and running. Put this after customizations so that ~package-load-list~ can be customized. Make sure to activate or the following ~(require 'use-package)~ will fail.
    #+begin_src emacs-lisp :tangle no
    (package-initialize)
    #+end_src

*** Chose preferred coding-system
    Since I work on Windows sometimes and some elpa packages are lacking the proper [[https://en.wikipedia.org/wiki/Byte_order_mark][byte order mark]] at the beginning of the file, I needed to perform the following to allow ~package-refresh-contents~ to finish without issue. It's not a bad idea to just do this ubiquitously, so I do it here.
    #+begin_src emacs-lisp :tangle no
    (prefer-coding-system 'utf-8)
    #+end_src

*** Get package contents
    Now refresh the package contents using the ~package-archives~ setting from the ~custom.el~ file. I modify this to include melpa, gnu, and org repositories.
    #+begin_src emacs-lisp :tangle no
    (package-refresh-contents)
    #+end_src

*** Assure use-package is loaded
    We need ~use-package~ to perform the remainder of this configuration
    #+begin_src emacs-lisp :tangle no
    (unless (package-installed-p 'use-package)
      (package-install 'use-package))
    (require 'use-package)
    #+end_src

*** Install org
    I use org-babel capabilities to load the configuration documented here. Make sure it's loaded and that it comes from the "org" repository (most up-to-date for org).
    #+begin_src emacs-lisp :tangle no
    (use-package org
      :demand t
      :pin "org")
    #+end_src

*** Now just babel load this file
    #+begin_src emacs-lisp :tangle no
    (org-babel-load-file "~/.emacs.d/README.org" t)
    #+end_src

* Configuration
** Just a little preamble
   This is a little piece of code that I picked up that might make things faster when downloading and installing all the packages. This turns down the garbage collector during the use-package loading when it has to do some compiling. Set it back when done with init.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq gc-cons-threshold 64000000)
     (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 800000)))
   #+END_SRC
  
   Also create a handy variable to know if we are Windows - used later on here.
   #+begin_src emacs-lisp :tangle yes
   (defvar mswindows-p (string-match "windows" (symbol-name system-type)))
   #+end_src

** General packages
   Here are some general packages
*** [[https://github.com/emacscollective/auto-compile][auto-compile]]
    This package provides a guarantee that compiled byte code files are never outdated by mistake. You'll want to modify the variable ~load-prefer-newer~.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package auto-compile
        :config
        (progn
          (auto-compile-on-load-mode)
          (auto-compile-on-save-mode)))
    #+END_SRC
*** [[https://github.com/myrjola/diminish.el][diminish]]
    Handy mode to make the modeline nicer. I also use to set mode to special characters (for example, see flycheck-mode)
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package diminish)
    #+END_SRC
*** [[https://github.com/priyadarshan/bind-key][bind-key]]
    Much better binding capabilities
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package bind-key)
    #+END_SRC
*** savehist
    A great builtin that allows us to have a history file. This means certain elements are saved between sessions of emacs. Set the following variables to control ~savehist~ (use customize).
    1. ~savehist-additional-variables~ - ~(kill-ring search-ring regexp-search-ring)~
    2. ~savehist-file~ => ~"~/.emacs.d/savehist"~
    3. ~savehist-mode~ => t
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package savehist :demand t)                ;; Nice history in ~/.emacs.d/savehist
    #+END_SRC
*** [[https://github.com/Wilfred/ag.el][ag]]
    AKA silversearcher. Simple interface to excellent tool. I have it installed in my cygwin64 area and it seems to play well in my Windows environment.

    NB: doesn't seem to work so well under Windows.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ag)
    #+END_SRC
*** [[http://github.com/jschaf/powershell.el][powershell]]
    Excellent too to run powershell in Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package powershell
        :if mswindows-p)
    #+END_SRC
*** themes and modeline
    #+BEGIN_SRC emacs-lisp :tangle yes
      (load-theme 'leuven t)                          ;; Theme: works better before powerline
      (use-package powerline
        :demand t
        :config (powerline-default-theme))
    #+END_SRC
*** aspx editing
    Make aspx editing more palatable using html mode
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'auto-mode-alist
                   '("\\.aspx\\'" . html-mode)
                   '("\\.aspcx\\'" . html-mode))
    #+END_SRC
*** Other useful packages
    Ok, a little tired of documenting each package on it's own. These packages are just generally useful.

    ~which-key~ very helpful for finding way around.

    The ~desktop~ package allows for saved desktops in the emacs start directory (~desktop-path~ gets set here). Modify ~desktop-save-mode~ to t to turn on desktop saving.

    Make sure to customize ~projectile-completion-system~ to "ivy".
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package realgud :demand t)
      (use-package projectile :demand t :config (projectile-mode t))
      (use-package ibuffer-projectile)
      (use-package xterm-color)
      (use-package which-key :demand t :diminish "")
      (use-package sh-script)
      (use-package desktop
        :config
        ;; put desktop in Emacs start directory
        (set-variable 'desktop-path (cons default-directory desktop-path)))
      (use-package paredit
        :demand t
        :config
        (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode))
    #+END_SRC

* Working with C#
  Because I'm a C# developer and pretty much dislike a lot of the GUI issues in Visual Studio, I've spent some amount of time coming up with a good C# configuration. This works spectularly well and takes only minutes to setup.

  To use omnisharp follow these directions:
  1. Load up local omnisharp (roslyn flavor) from [[https://github.com/OmniSharp/omnisharp-roslyn/releases][Omnisharp-Roslyn releases]]
  2. Customize the variable ~omnisharp-server-executable-path~ to point to your omnisharp roslyn. For example "c:/omnisharp-roslyn-v1.27.2/OmniSharp.exe".
  There are comprehensive directions at [[https://github.com/OmniSharp/omnisharp-emacs.git][omnisharp-emacs]].

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar config/use-omnisharp nil)
    (let ((omnisharp (car (get 'omnisharp-server-executable-path 'saved-value))))
      (unless (null omnisharp)
        (setq config/use-omnisharp (file-exists-p omnisharp))))

    (use-package omnisharp
      :diminish "\u221e"                            ;; infinity symbol
      :if config/use-omnisharp
      :bind (:map omnisharp-mode-map
                  ("C-c o" . omnisharp-start-omnisharp-server)
                  ("C-c d" . omnisharp-go-to-definition-other-window)
                  ("C-x C-j" . counsel-imenu)))
    (use-package csharp-mode
      :config
      (when config/use-omnisharp
        (add-hook 'csharp-mode-hook 'company-mode)
        (add-hook 'csharp-mode-hook 'omnisharp-mode)))
  #+END_SRC

* [[https://github.com/magit/magit][magit]] configuration
  The most awesome git porcelain. Most here are part of magit, ~[[https://github.com/pidu/git-timemachine][git-time-machine]]~ is not, but well worth using.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package git-commit)
    (use-package magit
      :demand t
      :bind (("C-c f" . magit-find-file-other-window)
             ("C-c g" . magit-status)
             ("C-c l" . magit-log-buffer-file))
      ;; Make the default action a branch checkout, not a branch visit when in branch mode
      :bind (:map magit-branch-section-map
                  ([remap magit-visit-thing] . magit-branch-checkout)))
    (use-package magit-filenotify)
    (use-package magit-find-file)
    (use-package git-timemachine)
  #+END_SRC

* org-mode configuration
  Org mode configurations. ~org-bullets~ used to be part of org but is now outside
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package org-bullets
       :demand t
       :config (add-hook 'org-mode-hook 'org-bullets-mode))
    (use-package org-autolist
       :demand t)
    (use-package org-projectile)
  #+END_SRC

* python configuration
  At one point I was using anaconda but have switched back to elpy. I really like ~eply-config~ that tells you if everything is working properly. I've been using a ~virtualenv~ for my python development and couldn't be happier. Perhaps ethe only thing that bothers me is that when an object is returned, pycharm will give you list and dictionary methods while eply/company does not. Seems to be the only real issue at this point.

  The variables that might be setup for python (look in [[file:custom.el][custom.el]] for them):
  1. ~python-indent-trigger-commands~ 
  2. ~python-shell-completion-setup-code~
  3. ~python-shell-completion-string-code~
  4. ~python-shell-interpreter~
  5. ~python-shell-interpreter-args~
  6. ~python-shell-prompt-output-regexp~
  7. ~python-shell-prompt-regexp~

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company
      :diminish "Co"
      :config
      (when config/use-omnisharp
        (add-to-list 'company-backends 'company-omnisharp)))
    (use-package company-jedi)
    (use-package elpy
      :demand t
      :config
      (progn
        (elpy-enable)
        (add-hook 'elpy-mode-hook
                  '(lambda ()
                     (progn
                       (setq-local flymake-start-syntax-check-on-newline t)
                       (setq-local flymake-no-changes-timeout 0.5))))))
    (use-package flycheck
      :diminish  "\u2714"           ;; heavy checkmark
      :config
      (global-flycheck-mode))
    (use-package flycheck-pyflakes) ;; flycheck uses flake8!
    (use-package pylint)
    (use-package python-docstring
      :config
      (python-docstring-install))
    (use-package python
      :config
      (progn
        (add-hook 'python-mode-hook '(lambda () (add-to-list 'company-backends 'company-jedi)))
        (add-hook 'python-mode-hook 'flycheck-mode)
        (add-hook 'python-mode-hook 'company-mode)))
  #+END_SRC

* ivy configuration
  Was a help user, but switched to ivy. Lots of nice features in ivy
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy
      :demand t
      :diminish ""
      :bind (:map ivy-minibuffer-map
                  ("C-w" . ivy-yank-word)           ;; make work like isearch
                  ("C-r" . ivy-previous-line))
      :config
      (progn
        (setq ivy-initial-inputs-alist nil)         ;; no regexp by default
        (setq ivy-re-builders-alist                 ;; allow input not in order
              '((t . ivy--regex-ignore-order)))))
    (use-package counsel
      :bind (("M-x" . counsel-M-x)
             ("C-x g" . counsel-git)
             ("C-x C-f" . counsel-find-file)
             ("C-x C-j" . counsel-imenu))
      :bind (:map help-map
                  ("f" . counsel-describe-function)
                  ("v" . counsel-describe-variable)
                  ("b" . counsel-descbinds)))
    (use-package counsel-projectile
      :demand t
      :config
      (counsel-projectile-mode t))
    (use-package counsel-etags)
    (use-package ivy-hydra)
    (use-package swiper
      :bind (("C-S-s" . isearch-forward)
             ("C-s" . swiper)
             ("C-S-r" . isearch-backward)
             ("C-r" . swiper)))
    (use-package avy)
  #+END_SRC
* yasnippet configuration
  yasnippet is a truly awesome package. Local modifications should go in "~/.emacs.d/snippets/".

  This also takes care of hooking up company completion with yasnippet expansion.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package warnings :demand t)
    (use-package yasnippet
      :diminish (yas-minor-mode . "")
      :config
      (progn
        (yas-reload-all)
        ;; fix tab in term-mode
        (add-hook 'term-mode-hook (lambda() (yas-minor-mode -1)))
        ;; Fix yas indent issues
        (add-hook 'python-mode-hook '(lambda () (set (make-local-variable 'yas-indent-line) 'fixed)))
        ;; Setup to allow for yasnippets to use code to expand
        (add-to-list 'warning-suppress-types '(yasnippet backquote-change))))
    (use-package yasnippet-snippets :demand t)      ;; Don't forget the snippets

    (defvar company-mode/enable-yas t "Enable yasnippet for all backends.")
    (defun company-mode/backend-with-yas (backend)
      "Add in the company-yasnippet BACKEND."
      (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
          backend
        (append (if (consp backend) backend (list backend))
                '(:with company-yasnippet))))
    (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
  #+END_SRC

* Additional bits-o-configuration
** Limit the length of ~which-function~
   ~which-function~ which is used by ~powerline~ has no maximum method/function signature. This handy advisor limits the name to 64 characters.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar  which-function-max-width 64 "The maximum width of the which-function string.")
     (advice-add 'which-function :filter-return
                 (lambda (s) (if (< (string-width s) which-function-max-width) s
                               (concat (truncate-string-to-width s (- which-function-max-width 3)) "..."))))
   #+END_SRC
** ~my-ansi-term~                               
   Allows me to name my ANSI terms. Was very useful when I used more ANSI shells (so that tabs were interpretted by the shell). Some other modes and shells make this less useful these days.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-ansi-term (term-name cmd)
       "Create an ansi term with a name - other than *ansi-term* given TERM-NAME and CMD."
       (interactive "sName for terminal: \nsCommand to run [/bin/bash]: ")
       (ansi-term (if (= 0 (length cmd)) "/bin/bash" cmd))
       (rename-buffer term-name))
   #+END_SRC
** Understand file type by shebang
   When a file is opened and it is determined there is no mode (fundamental-mode) this code reads the first line of the file looking for an appropriate shebang for either python or bash and sets the mode for the file.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-find-file-hook ()
       "If `fundamental-mode', look for script type so the mode gets properly set.
     Script-type is read from #!/... at top of file."
       (if (eq major-mode 'fundamental-mode)
           (condition-case nil
               (save-excursion
                 (goto-char (point-min))
                 (re-search-forward "^#!\s*/.*/\\(python\\|bash\\).*$")
                 (if (string= (match-string 1) "python")
                     (python-mode)
                   (sh-mode)))
             (error nil))))
     (add-hook 'find-file-hook 'my-find-file-hook)
   #+END_SRC

** Additional configs
   Setup ~eldoc~ mode, use y-or-n (instead of yes and no). Key bindings...
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)    ;; Run elisp with eldoc-mode
     (fset 'list-buffers 'ibuffer)                   ;; prefer ibuffer over list-buffers
     (fset 'yes-or-no-p 'y-or-n-p)                   ;; for lazy people use y/n instead of yes/no
     (diminish 'eldoc-mode "Doc")                    ;; Diminish eldoc-mode

     ;; Some key bindings
     (bind-key "C-x p" 'pop-to-mark-command)
     (bind-key "C-h c" 'customize-group)
     (bind-key "C-+" 'text-scale-increase)
     (bind-key "C--" 'text-scale-decrease)
     (bind-key "C-z" 'nil)                           ;; get rid of pesky "\C-z"
     (bind-key "C-z" 'nil ctl-x-map)                 ;;    and "\C-x\C-z" annoying minimize
     (bind-key "C-c C-d" 'dired-jump)
     (bind-key "C-c r" 'revert-buffer)
     (bind-key "C-c t" 'toggle-truncate-lines)
     (bind-key "C-c c" 'comment-region)
     (bind-key "C-c u" 'uncomment-region)
     (bind-key "<up>" 'enlarge-window ctl-x-map)     ;; note: C-x
     (bind-key "<down>" 'shrink-window ctl-x-map)    ;; note: C-x

     (setq-default ediff-ignore-similar-regions t)   ;; Not a variable but controls ediff

     ;; Turn on some stuff that's normally set off
     (put 'narrow-to-region 'disabled nil)
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
     (put 'scroll-left 'disabled nil)
  #+END_SRC

